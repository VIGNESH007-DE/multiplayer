<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Quiz - Multiplayer</title>
    <style>
        /* Basic Setup and Theming */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --background-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --font-color: #dcdcdc;
            --money-color: #ffc107;
            --correct-color: #4caf50;
            --incorrect-color: #f44336;
            --border-radius: 12px;
            --timer-color: #00bcd4;
        }

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--background-color);
            color: var(--font-color);
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            perspective: 1000px;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            height: 95vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-color: var(--primary-color);
            border-radius: var(--border-radius);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        /* Screens */
        #login-screen, #finding-game-screen, #game-screen, #final-scores-screen {
            display: none;
            text-align: center;
            width: 100%;
        }
        
        #login-screen.active, #finding-game-screen.active, #game-screen.active, #final-scores-screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        
        h1, h2, h3 {
             font-family: 'Press Start 2P', cursive;
        }

        /* Login Screen */
        #login-screen h1 { color: var(--accent-color); text-shadow: 2px 2px #000; }
        .login-form input, .login-form button {
            font-family: 'Press Start 2P', cursive;
            display: block;
            width: 80%;
            max-width: 300px;
            margin: 15px auto;
            padding: 15px;
            border-radius: var(--border-radius);
        }
        .login-form input { border: 2px solid var(--secondary-color); background-color: var(--background-color); color: var(--font-color); font-size: 14px; }
        .login-form button { border: none; background-color: var(--accent-color); color: white; cursor: pointer; font-size: 16px; transition: transform 0.2s; }
        .login-form button:hover { transform: scale(1.05); }

        /* Game Screen Layout */
        #game-screen {
            justify-content: space-between;
        }
        #opponent-info, #player-info {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: var(--secondary-color);
            border-radius: var(--border-radius);
        }
        .player-hud-name { font-size: 16px; font-weight: bold; }
        .player-hud-money { font-size: 20px; color: var(--money-color); font-weight: bold; }
        
        /* Play Area */
        #play-area {
            width: 100%;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            position: relative;
        }

        #timer-display {
            position: absolute;
            top: 10px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: var(--timer-color);
        }

        #question-display {
            background: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: var(--border-radius);
            min-height: 80px;
            width: 90%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #question-text { font-size: clamp(16px, 2.5vw, 24px); line-height: 1.5; font-weight: bold; }

        #played-cards-area {
            display: flex;
            gap: 20px;
            min-height: 150px; /* Card height */
            align-items: center;
        }

        /* Player Hand */
        #player-hand {
            display: flex;
            justify-content: center;
            gap: -20px; /* Overlap cards */
            width: 100%;
            padding-bottom: 20px;
        }

        /* Card Styling & Animations */
        .card {
            width: 120px;
            height: 150px;
            background: linear-gradient(145deg, var(--secondary-color), #223e71);
            border: 2px solid var(--timer-color);
            border-radius: var(--border-radius);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            transform-style: preserve-3d;
        }
        
        #player-hand .card {
            transform-origin: bottom center;
        }
        
        #player-hand .card:hover {
            transform: translateY(-20px) scale(1.05);
            z-index: 10;
        }

        .card.played {
            cursor: default;
            position: relative;
        }

        .card .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: var(--border-radius);
        }

        .card .card-front {
            /* Content is already there */
        }
        
        .card .card-back {
            transform: rotateY(180deg);
            font-size: 24px;
        }

        .card.is-flipping {
            animation: flip 0.6s ease;
        }

        @keyframes flip {
            from { transform: rotateY(0deg); }
            to { transform: rotateY(180deg); }
        }

        .card.correct .card-back { background: var(--correct-color); }
        .card.incorrect .card-back { background: var(--incorrect-color); }
        
        .card.entering {
            animation: deal-in 0.5s ease-out forwards;
            opacity: 0;
        }
        
        .card:nth-child(1) { animation-delay: 0.1s; }
        .card:nth-child(2) { animation-delay: 0.2s; }
        .card:nth-child(3) { animation-delay: 0.3s; }
        
        @keyframes deal-in {
            from { transform: translateY(100px) rotate(15deg); opacity: 0; }
            to { transform: translateY(0) rotate(0); opacity: 1; }
        }

        /* Final Scores Screen */
        #final-scores-screen { gap: 20px; }
        #winner-announcement { font-size: 24px; color: var(--money-color); }
        #final-scores-list { text-align: left; max-width: 400px; width: 100%; }
        .score-item { display: flex; justify-content: space-between; padding: 10px; background-color: var(--secondary-color); border-radius: var(--border-radius); margin-bottom: 10px; font-size: 16px; }
        .score-item.winner { background-color: var(--money-color); color: #000; }
        #exit-game-btn { font-family: 'Press Start 2P', cursive; border: none; background-color: var(--accent-color); color: white; cursor: pointer; font-size: 16px; padding: 15px 30px; border-radius: var(--border-radius); transition: transform 0.2s; }
        #exit-game-btn:hover { transform: scale(1.05); }

    </style>
</head>
<body>

    <div class="container">
        <!-- Login Screen -->
        <div id="login-screen" class="active">
            <h1>Card Quiz</h1>
            <div class="login-form">
                <input type="text" id="student-name" placeholder="Enter Your Name">
                <input type="text" id="school-code" placeholder="Enter School Code">
                <button id="join-game-btn">Join Game</button>
            </div>
        </div>

        <!-- Finding Game Screen -->
        <div id="finding-game-screen">
            <h2>Finding a Game Room...</h2>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div id="opponent-info">
                <div id="opponent-name" class="player-hud-name">Opponent</div>
                <div id="opponent-money" class="player-hud-money">$100</div>
            </div>

            <div id="play-area">
                <div id="timer-display">30</div>
                <div id="question-display">
                    <p id="question-text">Waiting for game to start...</p>
                </div>
                <div id="played-cards-area">
                     <!-- Cards played by players will appear here -->
                </div>
            </div>

            <div id="player-hand">
                <!-- Player's cards will be generated here -->
            </div>

            <div id="player-info">
                <div id="player-name" class="player-hud-name">You</div>
                <div id="player-money" class="player-hud-money">$100</div>
            </div>
        </div>
        
        <!-- Final Scores Screen -->
        <div id="final-scores-screen">
            <h2>Game Over!</h2>
            <h3 id="winner-announcement"></h3>
            <h4>Final Scores:</h4>
            <div id="final-scores-list"></div>
            <button id="exit-game-btn">Exit to Menu</button>
        </div>

    </div>

    <script type="module">
        const firebaseConfig = {
            apiKey: "AIzaSyDL3QZhvVDiml0bH7ZZlaO1RkcWdedjKg4",
            authDomain: "bossbattlequiz.firebaseapp.com",
            databaseURL: "https://bossbattlequiz-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "bossbattlequiz",
            storageBucket: "bossbattlequiz.appspot.com",
            messagingSenderId: "629524990741",
            appId: "1:629524990741:web:5bd5b16409b51d847a371c",
            measurementId: "G-1SSFHVFCF1"
        };
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getDatabase, ref, set, onValue, onDisconnect, runTransaction, serverTimestamp, get } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        
        const screens = {
            login: document.getElementById('login-screen'),
            finding: document.getElementById('finding-game-screen'),
            game: document.getElementById('game-screen'),
            scores: document.getElementById('final-scores-screen'),
        };
        const studentNameInput = document.getElementById('student-name');
        const schoolCodeInput = document.getElementById('school-code');
        const joinGameBtn = document.getElementById('join-game-btn');
        const questionText = document.getElementById('question-text');
        const playerHand = document.getElementById('player-hand');
        const playedCardsArea = document.getElementById('played-cards-area');
        const winnerAnnouncement = document.getElementById('winner-announcement');
        const finalScoresList = document.getElementById('final-scores-list');
        const exitGameBtn = document.getElementById('exit-game-btn');
        const timerDisplay = document.getElementById('timer-display');

        let currentUid = null;
        let currentRoomId = null;
        let isProcessingRound = false;
        let questionTimer = null;
        let lastKnownRoomData = null;
        let lastQuestionStartTime = null;
        const QUESTION_TIME = 30000; // 30 seconds

        try {
            const app = initializeApp(firebaseConfig);
            const db = getDatabase(app);
            const auth = getAuth(app);
            
            function showScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.remove('active'));
                screens[screenName]?.classList.add('active');
            }
            
            joinGameBtn.addEventListener('click', async () => {
                const name = studentNameInput.value.trim();
                const schoolCode = schoolCodeInput.value.trim();
                if (!name || !schoolCode) return alert("Please enter name and school code.");
                try {
                    const userCredential = await signInAnonymously(auth);
                    currentUid = userCredential.user.uid;
                    await findOrCreateRoom({ name, schoolCode });
                } catch (error) { console.error("Auth/Login Error:", error); alert("Could not log you in."); }
            });
            
            exitGameBtn.addEventListener('click', () => window.location.reload());

            async function findOrCreateRoom(playerData) {
                showScreen('finding');
                const gamesRef = ref(db, 'games');
                let isGameStarter = false;
                
                try {
                    await runTransaction(gamesRef, (games) => {
                        if (!games) games = {};
                        let joinedRoomId = null;
                        
                        for (const [roomId, roomData] of Object.entries(games)) {
                            const players = roomData.players || {};
                            if (roomData.gameState === 'LOBBY' && Object.keys(players).length < 2) {
                                joinedRoomId = roomId;
                                break;
                            }
                        }

                        if (joinedRoomId) {
                            games[joinedRoomId].players[currentUid] = { ...playerData, money: 100, score: 0, playedCard: null };
                            if (Object.keys(games[joinedRoomId].players).length === 2) {
                                games[joinedRoomId].gameState = 'IN_PROGRESS';
                                isGameStarter = true;
                            }
                            currentRoomId = joinedRoomId;
                        } else {
                            const newRoomId = 'room_' + Math.random().toString(36).substr(2, 5);
                            games[newRoomId] = {
                                gameState: 'LOBBY',
                                players: { [currentUid]: { ...playerData, money: 100, score: 0, playedCard: null } },
                                currentQuestion: { text: "Game is about to start...", answer: "" },
                                askedQuestions: {}
                            };
                            currentRoomId = newRoomId;
                        }
                        return games;
                    });

                    if (currentRoomId) {
                        const playerRef = ref(db, `games/${currentRoomId}/players/${currentUid}`);
                        onDisconnect(playerRef).remove();
                        listenToRoomState(currentRoomId);
                        if (isGameStarter) await setNextQuestion(currentRoomId, true);
                    } else { throw new Error("Failed to get a room ID from transaction."); }
                } catch (error) { console.error("Could not find or create room:", error); alert("Error finding a game room."); showScreen('login'); }
            }
            
            function listenToRoomState(roomId) {
                const roomStateRef = ref(db, `games/${roomId}`);
                onValue(roomStateRef, (snapshot) => {
                    const room = snapshot.val();
                    if (!room) {
                        window.location.reload(); 
                        return;
                    }
                    const { gameState, currentQuestion, players } = room;

                    if (gameState === 'IN_PROGRESS' && Object.keys(players || {}).length < 2) {
                         if (players && players[currentUid]) {
                            let disconnectedPlayerName = "The other player";
                            if(lastKnownRoomData && lastKnownRoomData.players) {
                                const oldPlayerIds = Object.keys(lastKnownRoomData.players);
                                const newPlayerIds = Object.keys(players);
                                const disconnectedId = oldPlayerIds.find(id => !newPlayerIds.includes(id));
                                if(disconnectedId) disconnectedPlayerName = lastKnownRoomData.players[disconnectedId].name;
                            }
                            winnerAnnouncement.textContent = `${disconnectedPlayerName} disconnected. You win!`;
                            renderFinalScores(players);
                            showScreen('scores');
                         }
                         return;
                    }

                    switch (gameState) {
                        case 'IN_PROGRESS': showScreen('game'); break;
                        case 'FINISHED':
                            stopTimer();
                            renderFinalScores(players);
                            showScreen('scores');
                            return;
                        default: // LOBBY
                           questionText.textContent = "Waiting for another player...";
                           showScreen('game');
                           break;
                    }
                    
                    questionText.textContent = currentQuestion.text;
                    renderPlayers(players);
                    
                    if (gameState === 'IN_PROGRESS' && currentQuestion.startTime && currentQuestion.startTime !== lastQuestionStartTime) {
                        lastQuestionStartTime = currentQuestion.startTime;
                        startTimer();
                    }
                    
                    if (players && Object.values(players).every(p => p.playedCard !== null) && !isProcessingRound) {
                        isProcessingRound = true;
                        stopTimer();
                        setTimeout(() => revealCards(room), 1000);
                    }
                    lastKnownRoomData = room;
                });
            }

            function startTimer() {
                stopTimer();
                let timeLeft = QUESTION_TIME / 1000;
                timerDisplay.textContent = timeLeft;

                const interval = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = timeLeft;
                    if (timeLeft <= 0) clearInterval(interval);
                }, 1000);

                questionTimer = setTimeout(() => {
                    clearInterval(interval);
                    handleTimeout();
                }, QUESTION_TIME);
            }

            function stopTimer() {
                clearTimeout(questionTimer);
            }

            async function handleTimeout() {
                const playerStateRef = ref(db, `games/${currentRoomId}/players/${currentUid}`);
                const snapshot = await get(playerStateRef);
                if (snapshot.exists() && snapshot.val().playedCard === null) {
                    set(ref(db, `games/${currentRoomId}/players/${currentUid}/playedCard`), "TIMED_OUT");
                }
            }
            
            function renderPlayers(players) {
                if (!players || !currentUid) return;
                const playerIds = Object.keys(players);
                const opponentId = playerIds.find(id => id !== currentUid);
                
                const myData = players[currentUid];
                document.getElementById('player-name').textContent = myData.name;
                document.getElementById('player-money').textContent = `$${myData.money}`;
                renderHand(myData.hand, myData.playedCard);

                if (opponentId) {
                    const opponentData = players[opponentId];
                    document.getElementById('opponent-name').textContent = opponentData.name;
                    document.getElementById('opponent-money').textContent = `$${opponentData.money}`;
                    renderPlayedCard('opponent', opponentData.playedCard);
                } else {
                    document.getElementById('opponent-name').textContent = 'Waiting...';
                    document.getElementById('opponent-money').textContent = '';
                }
            }

            function renderHand(hand, playedCard) {
                playerHand.innerHTML = '';
                if (!hand) return;
                hand.forEach((answer) => {
                    const card = document.createElement('div');
                    card.className = 'card entering';
                    card.textContent = answer;
                    if (playedCard) {
                        card.style.pointerEvents = 'none';
                        if (playedCard !== answer) card.style.opacity = '0.5';
                    } else {
                        card.onclick = () => playCard(answer);
                    }
                    playerHand.appendChild(card);
                });

                renderPlayedCard('player', playedCard);
            }
            
            function renderPlayedCard(who, cardText) {
                let cardSlotId = who === 'player' ? 'player-played-card' : 'opponent-played-card';
                let existingCard = document.getElementById(cardSlotId);
                
                if (!cardText) {
                    if (existingCard) existingCard.remove();
                    return;
                }
                
                if (!existingCard) {
                    existingCard = document.createElement('div');
                    existingCard.id = cardSlotId;
                    existingCard.className = 'card played';
                    if (who === 'player') playedCardsArea.appendChild(existingCard);
                    else playedCardsArea.prepend(existingCard);
                }

                const frontText = who === 'opponent' ? '???' : cardText;
                existingCard.innerHTML = `<div class="card-face card-front">${frontText}</div><div class="card-face card-back"></div>`;
            }

            function playCard(answer) {
                stopTimer();
                playerHand.querySelectorAll('.card').forEach(c => c.style.pointerEvents = 'none');
                const playerRef = ref(db, `games/${currentRoomId}/players/${currentUid}/playedCard`);
                set(playerRef, answer);
            }

            function revealCards(room) {
                const { players, currentQuestion } = room;
                const correctAnswer = currentQuestion.answer;

                Object.keys(players).forEach(uid => {
                    const who = uid === currentUid ? 'player' : 'opponent';
                    const cardSlotId = `${who}-played-card`;
                    const cardEl = document.getElementById(cardSlotId);
                    if (cardEl) {
                        const playerAnswer = players[uid].playedCard;
                        const cardFront = cardEl.querySelector('.card-front');
                        if (cardFront) cardFront.textContent = playerAnswer === "TIMED_OUT" ? "Too Slow!" : playerAnswer;
                        
                        const isCorrect = playerAnswer.toLowerCase() === correctAnswer.toLowerCase();
                        cardEl.classList.add('is-flipping');
                        cardEl.classList.add(isCorrect ? 'correct' : 'incorrect');
                        const backFace = cardEl.querySelector('.card-back');
                        backFace.textContent = isCorrect ? '✔️' : '❌';
                    }
                });
                
                setTimeout(() => processRoundResults(), 2500);
            }

            function processRoundResults() {
                 const roomRef = ref(db, `games/${currentRoomId}`);
                 runTransaction(roomRef, (currentRoom) => {
                     if (!currentRoom) return;
                     const needsProcessing = Object.values(currentRoom.players || {}).some(p => p.playedCard !== null);
                     if (!needsProcessing) return; 

                     const correctAnswer = (currentRoom.currentQuestion.answer || '').toLowerCase();
                     Object.keys(currentRoom.players).forEach(uid => {
                         const player = currentRoom.players[uid];
                         if (player && player.playedCard) {
                            if (player.playedCard === "TIMED_OUT") {
                                player.money -= 10;
                            } else {
                                const isCorrect = player.playedCard.toLowerCase() === correctAnswer;
                                if (isCorrect) player.score += 10;
                                else player.money -= 20;
                            }
                         }
                     });
                     return currentRoom;
                 }).then((result) => {
                     if (!result.committed) return;
                     const playerRef = ref(db, `games/${currentRoomId}/players`);
                     get(playerRef).then(snapshot => {
                         const players = snapshot.val();
                         if (players && Object.values(players).some(p => p.money <= 0)) {
                             set(ref(db, `games/${currentRoomId}/gameState`), 'FINISHED');
                         } else {
                             setNextQuestion(currentRoomId);
                         }
                     });
                 }).catch((error) => {
                     console.log("Transaction likely handled by other client.", error.message);
                 });
            }

            async function setNextQuestion(roomId, isFirstQuestion = false) {
                try {
                    const allQuestionsRef = ref(db, 'questions');
                    const questionsSnapshot = await get(allQuestionsRef);
                    const allQuestions = questionsSnapshot.val();
                    if (!allQuestions) throw new Error("Question bank is empty.");

                    const roomRef = ref(db, `games/${roomId}`);
                    await runTransaction(roomRef, (room) => {
                        if (!room || (room.gameState !== 'IN_PROGRESS' && !isFirstQuestion)) return;
                        
                        const askedIds = room.askedQuestions ? Object.keys(room.askedQuestions) : [];
                        const unaskedQuestionIds = Object.keys(allQuestions).filter(id => !askedIds.includes(id));

                        if (unaskedQuestionIds.length > 0) {
                            const randomQuestionId = unaskedQuestionIds[Math.floor(Math.random() * unaskedQuestionIds.length)];
                            const nextQ = allQuestions[randomQuestionId];
                            
                            const distractorOptions = Array.isArray(nextQ.options) && nextQ.options.length >= 2 
                                ? nextQ.options 
                                : ["Wrong Answer A", "Wrong Answer B"];

                            Object.keys(room.players).forEach(uid => {
                                const player = room.players[uid];
                                let handOptions = [...distractorOptions];
                                for (let i = handOptions.length - 1; i > 0; i--) {
                                    const j = Math.floor(Math.random() * (i + 1));
                                    [handOptions[i], handOptions[j]] = [handOptions[j], handOptions[i]];
                                }
                                player.hand = [nextQ.answer, ...handOptions.slice(0, 2)];
                                for (let i = player.hand.length - 1; i > 0; i--) {
                                    const j = Math.floor(Math.random() * (i + 1));
                                    [player.hand[i], player.hand[j]] = [player.hand[j], player.hand[i]];
                                }
                                player.playedCard = null;
                            });

                            room.currentQuestion = { text: nextQ.text, answer: nextQ.answer, startTime: serverTimestamp() };
                            if (!room.askedQuestions) room.askedQuestions = {};
                            room.askedQuestions[randomQuestionId] = true;
                        } else {
                            room.gameState = 'FINISHED';
                        }
                        return room;
                    });
                    isProcessingRound = false;
                } catch (error) { console.error("Failed to set next question:", error); }
            }
            
             function renderFinalScores(players) {
                finalScoresList.innerHTML = '';
                if (!players) {
                    winnerAnnouncement.textContent = "Game Over";
                    return;
                };
                const sortedPlayers = Object.entries(players).sort((a, b) => b[1].score - a[1].score);
                if(sortedPlayers.length > 0) {
                    if (sortedPlayers.length === 1) {
                         const winnerName = sortedPlayers[0][1].name;
                         if (!winnerAnnouncement.textContent.includes("disconnected")) {
                             winnerAnnouncement.textContent = `${winnerName} is the last one standing!`;
                         }
                    } else if (sortedPlayers[0][1].score === sortedPlayers[1][1].score) {
                         winnerAnnouncement.textContent = "It's a Tie!";
                    }
                    else {
                        const winnerName = sortedPlayers[0][1].name;
                        winnerAnnouncement.textContent = `${winnerName} Wins!`;
                    }
                }
                sortedPlayers.forEach(([uid, player], index) => {
                    const item = document.createElement('div');
                    item.className = 'score-item';
                    if (index === 0 && sortedPlayers.length > 1 && sortedPlayers[0][1].score > sortedPlayers[1][1].score) item.classList.add('winner');
                    item.innerHTML = `<span>${player.name}</span><span>${player.score} pts</span>`;
                    finalScoresList.appendChild(item);
                });
            }

        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            showScreen('login');
            alert("Configuration Error: Could not connect to Firebase.");
        }
    </script>
</body>
</html>

